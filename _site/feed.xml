<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 23 Dec 2019 23:27:34 +0700</pubDate>
    <lastBuildDate>Mon, 23 Dec 2019 23:27:34 +0700</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Select muli categories with rails + jquery</title>
        <description>&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

## Select muli categories

## sử dụng rails + jquery

- Author: [hungnv950](https://github.com/hungnv950)

- Repo: [https://github.com/Hungnv950/rails-select-multi-categories](https://github.com/Hungnv950/rails-select-multi-categories)

- Representor: [https://hungnv950.github.io/2019/12/14/slect-multy-categories/#/](https://hungnv950.github.io/2019/12/14/slect-multy-categories/#/)
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Vấn đề

  - Hầu hết các dự án out source và dự án rails cho thị trường Nhật nói chung việc làm việc với lựa chọn dữ liệu dùng checkbox là rất phổ biến.

  - ![problem](https://fluidsurveys.com/wp-content/uploads/2009/11/56.png)
  - Lựa chọn categories cho người dùng
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Cách giải quyết

  ![Vào code dự án cũ để xem lại.](https://as2.ftcdn.net/jpg/01/70/81/05/500_F_170810520_qTnUe8qFYZo6Rc9rcBpXuUvYDl4v1pDi.jpg &quot;Codding&quot;)
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Cách giải quyết

  &lt;p&gt; Vào code dự án cũ để xem lại. &lt;/p&gt;
  &lt;br /&gt;

  ![Vào code dự án cũ để xem lại.](https://letweb.net/wp-content/uploads/2018/07/Source-Code-M%C3%A3-ngu%E1%BB%93n-l%C3%A0-g%C3%AC.png)
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Cách giải quyết

  ![alt text](https://res.cloudinary.com/drdoqfhly/image/upload/v1530887094/gg-1_synrgy.jpg)
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Cách giải quyết

  Tạo 1 base code:
   - Đơn giản
   - Dễ hiểu
   - Đúng vấn đề
   - Có thể tái sử dụng
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt; Các bước cần làm &lt;/h3&gt;
  &lt;ol&gt;
    &lt;li&gt;Tìm hiểu bài toán&lt;/li&gt;
    &lt;li&gt;Cấu trúc database&lt;/li&gt;
    &lt;li&gt;Khởi tạo model&lt;/li&gt;
    &lt;li&gt;Xây dựng form checkbox&lt;/li&gt;
    &lt;li&gt;Lưu trữ dữ liệu&lt;/li&gt;
    &lt;li&gt;Lấy giá trị&lt;/li&gt;
  &lt;/ol&gt;
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Tìm hiểu bài toán

  ![problem](https://fluidsurveys.com/wp-content/uploads/2009/11/56.png)
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Cấu trúc database

  ![Select multi categories db](/assets/images/multi-categories-db.png)
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt; Khởi tạo model &lt;/h3&gt;

  &lt;pre style=&quot;width: 100%;&quot;&gt;
  &lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
    # frozen_string_literal: true
    class User &amp;lt; ApplicationRecord
      has_many :users_categories, foreign_key: :user_id, dependent: :destroy
    end
	&lt;/code&gt;&lt;/pre&gt;

  &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
    # frozen_string_literal: true
    class Category &amp;lt; ApplicationRecord
      has_many :users_categories, foreign_key: :category_id,
        dependent: :destroy
    end
	&lt;/code&gt;&lt;/pre&gt;

  &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
    # frozen_string_literal: true
    class UsersCategory &amp;lt; ApplicationRecord
      belongs_to :user, foreign_key: :user_id
      belongs_to :category, class_name: Category.name
    end
	&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Xây dựng form checkbox

  Yêu cầu:
  1. Generate form checkbox với dữ liệu category
  2. Khi lựa chọn vào &quot;other content&quot; sẽ xuất hiện input để nhập dữ liệu
  3. Trả lại đúng data khi validate sai
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Xây dựng form checkbox

  #### 1. Generate form checkbox với dữ liệu category

  Sử dụng nested attributes:
    - accepts_nested_attributes_for
    - fields_for
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Xây dựng form checkbox

  #### 1. Generate form checkbox với dữ liệu category

  - Thêm đoạn dưới vào model user:
    ```
    accepts_nested_attributes_for :users_categories, allow_destroy: true
    ```
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt;  Xây dựng form checkbox &lt;/h3&gt;
   &lt;h4&gt; 1. Generate form checkbox với dữ liệu category&lt;/h4&gt;
  - Trong users_controller/new tiến hành build giá trị cho users_categories:
    &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
    def new
      @user = User.new
      @category_options =
        Category.all.map do |category|
          UsersCategory.new category: category, user: @user
        end
    end
    &lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt;  Xây dựng form checkbox &lt;/h3&gt;
  &lt;h4&gt; 1. Generate form checkbox với dữ liệu category&lt;/h4&gt;
  Hiển thị dữ liệu trên view với fields_for:
  &lt;br /&gt;
  fields_for(record_name, record_object = nil, options = {}, &amp;amp;block)
  &lt;br /&gt;
  check_box(object_name, method, options = {}, checked_value = &quot;1&quot;, unchecked_value = &quot;0&quot;)
  &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
&amp;lt;%= form_for @user do |f| %&amp;gt;
  &amp;lt;%= f.object.errors.full_messages %&amp;gt;
  username: &amp;lt;%= f.text_field :name %&amp;gt;
  categories:
    &amp;lt;%= f.fields_for :users_categories, @category_options do |ff| %&amp;gt;
      &amp;lt;% category_option = ff.object %&amp;gt;
      &amp;lt;%= ff.check_box :_destroy, {}, checked_value: &quot;0&quot;, unchecked_value: &quot;1&quot; %&amp;gt;
      &amp;lt;%= ff.hidden_field :category_id %&amp;gt;
      &amp;lt;%= category_option.content %&amp;gt;
    &amp;lt;% end %&amp;gt;
  &amp;lt;%= f.submit %&amp;gt;
&amp;lt;% end %&amp;gt;
    &lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ###  Xây dựng form checkbox

  #### 1. Generate form checkbox với dữ liệu category

  ```
  &amp;lt;%= ff.check_box :_destroy, {}, checked_value: &quot;0&quot;, unchecked_value: &quot;1&quot; %&amp;gt;
  ```
  - Mặc định `check_box` sẽ để `checked_value` = 1 và `unchecked_value` = 0. Nhưng trong trường hợp này những giá trị được checked sẽ đại diện cho `_destroy` có nghĩa là những checkbox nào được tích sẽ bị xóa.
  - Vì thế nên chúng ta sẽ đổi lại giá trị mặc định `checked_value: &quot;0&quot;` và `unchecked_value: &quot;1&quot;` để giữ lại những `user_categories` được tick.
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Xây dựng form checkbox

  #### 1. Generate form checkbox với dữ liệu category

  - Kết quả:
    ![Select multi categories db](/assets/images/select-multi-categories-form-checkbox.png)
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt;  Xây dựng form checkbox &lt;/h3&gt;
   &lt;h4&gt; 2. Khi lựa chọn vào &quot;other content&quot; sẽ xuất hiện input để nhập dữ liệu &lt;/h4&gt;
   &lt;p&gt; - Ý tưởng: Đối với category có key_name = &quot;other_content&quot; sẽ generate ra input và ẩn đi, khi người dùng click vào `other_content` sẽ show và hide &lt;/p&gt;
      &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
&amp;lt;%= form_for @user do |f| %&amp;gt;
  &amp;lt;%= f.object.errors.full_messages %&amp;gt;
  username: &amp;lt;%= f.text_field :name %&amp;gt;
  categories:
    &amp;lt;%= f.fields_for :users_categories, @category_options do |ff| %&amp;gt;
      &amp;lt;% users_categories = f.object.users_categories %&amp;gt;
      &amp;lt;% category_option = ff.object %&amp;gt;
        &amp;lt;%= ff.check_box :_destroy, {}, 0, 1 %&amp;gt;
        &amp;lt;%= ff.hidden_field :category_id %&amp;gt;
        &amp;lt;%= category_option.content %&amp;gt;

        # Thêm đoạn
        &amp;lt;% if category_option.key_name == &quot;other_content&quot; %&amp;gt;
          &amp;lt;%= ff.text_field :other_content, value: other_content,class: &quot;js-other_content-field hidden&quot; %&amp;gt;
        &amp;lt;% end %&amp;gt;

    &amp;lt;% end %&amp;gt;
  &amp;lt;%= f.submit %&amp;gt;
&amp;lt;% end %&amp;gt;
    &lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt;  Xây dựng form checkbox &lt;/h3&gt;
   &lt;h4&gt; 2. Khi lựa chọn vào &quot;other content&quot; sẽ xuất hiện input để nhập dữ liệu &lt;/h4&gt;
   &lt;p&gt; - Xử lý một chút JS đơn giản: &lt;/p&gt;
      &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
  $(function() {
    # Xử lý với trường hợp người dùng click vào `other_category`
    $('.js-select-other_content').change(function () {
      var self = $(this),
          otherContent = $('.js-other_content-field');
      if (self.is(':checked')) {
        otherContent.removeClass('hidden');
      } else {
        otherContent.addClass('hidden');
      }
    });
  });
    &lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Xây dựng form checkbox

  #### 2. Khi lựa chọn vào &quot;other content&quot; sẽ xuất hiện input để nhập dữ liệu

  - Kết quả:
    ![Select multi categories db](/assets/images/select-multi-categories-click-other.gif)
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Lưu trữ dữ liệu
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Lưu trữ dữ liệu

  - Permit data
  - Validate
  - Điền data cũ vào form nếu validate sai
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt; Lưu trữ dữ liệu &lt;/h3&gt;
  &lt;p&gt; 1.Permit data &lt;/p&gt;
  &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
  def user_params
    params.require(:user).permit(
      :name,
      users_categories_attributes: [:id, :category_id, :other_content, :_destroy]
    )
  end
    &lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt; Lưu trữ dữ liệu &lt;/h3&gt;
  &lt;p&gt; 2. Validate &lt;/p&gt;
  - số lượng category tối thiểu&lt;br /&gt;
  - validate nội dung của &quot;other content&quot; khi chọn checkbox này
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt; Lưu trữ dữ liệu &lt;/h3&gt;
  &lt;p&gt; 2. Validate &lt;/p&gt;
  &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
    # user.rb
MIN_SIZE = 1
# Validate số lượng tối thiểu categories
validates :users_categories, length: {minimum: MIN_SIZE}
  &lt;/code&gt;&lt;/pre&gt;

  Hoặc sử dụng custom validate:
    &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
      # user.rb
### Validate số lượng tối thiểu categories
MIN_SIZE = 1
validate :validate_users_categories

private
def validate_users_categories
  errors.add(:users_categories, :minsize) if(users_categories.size &amp;lt; MIN_SIZE)
end
  &lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt; Lưu trữ dữ liệu &lt;/h3&gt;
  &lt;p&gt; 2. Validate &lt;/p&gt;
  &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
    # users_category.rb
# Validate nội dung khi chọn &quot;other_content&quot;
validates :other_content, presence: true, if: lambda { key_name == &quot;other_content&quot;}
  &lt;/code&gt;&lt;/pre&gt;
  Hoặc sử dụng custom validate:
    &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
    # users_category.rb
    # Validate nội dung khi chọn &quot;other_content&quot;
    validate :validate_other_content
    private
    def validate_other_content
      errors.add(:other_content, :blank) if(key_name == OTHER_CONTENT &amp;amp;&amp;amp; other_content.blank?)
    end
  &lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Lưu trữ dữ liệu

  #### 3. Điền giá trị cũ vào form nếu validate sai

  Có 2 trường hợp cần xử lý:
    - Checkbox
    - Nội dung của &quot;other content&quot; nếu người dùng lựa chọn ô này.
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Lưu trữ dữ liệu

  #### 3. Điền giá trị cũ vào form nếu validate sai

  - Checkbox
    Ý tưởng: Khi submit dữ liệu lên controller, @user đã được gán giá trị khi &quot;@user = User.new user_params&quot;. Khi này, object @user đã được khởi tạo và có association.
    ![Select multi categories db](/assets/images/select-ml-ct-object-user.png)
  - Đây chính là những checkbox đã được checked
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt; Lưu trữ dữ liệu &lt;/h3&gt;
  &lt;h4&gt; 3. Điền giá trị cũ vào form nếu validate sai &lt;/h4&gt;

  &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
    # new.html.rb
    &amp;lt;%= form_for @user do |f| %&amp;gt;
      &amp;lt;%= f.object.errors.full_messages %&amp;gt;
      username: &amp;lt;%= f.text_field :name %&amp;gt;
      categories:
        &amp;lt;%= f.fields_for :users_categories, @category_options do |ff| %&amp;gt;
          &amp;lt;% users_categories = f.object.users_categories %&amp;gt;
          &amp;lt;% category_option = ff.object %&amp;gt;
          # Tìm kiếm users_categories có chứa category_option hiện tại hay không
          &amp;lt;% is_selected = users_categories.map{|c| c.key_name}.include?(category_option.key_name) %&amp;gt;
          # Lấy giá trị của &quot;Other content&quot;
          &amp;lt;% other_content = users_categories.select{|c| c.key_name == &quot;other_content&quot;}.first&amp;amp;.other_content %&amp;gt;
            &amp;lt;%= ff.check_box :_destroy, {checked: is_selected, class: &quot;#{'js-select-other_content' if category_option.key_name == 'other_content'}&quot;}, 0, 1 %&amp;gt;
            &amp;lt;%= ff.hidden_field :category_id %&amp;gt;
            &amp;lt;%= category_option.content %&amp;gt;
            &amp;lt;% if category_option.key_name == &quot;other_content&quot; %&amp;gt;
              &amp;lt;%= ff.text_field :other_content, value: other_content,class: &quot;js-other_content-field hidden&quot; %&amp;gt;
            &amp;lt;% end %&amp;gt;
        &amp;lt;% end %&amp;gt;
      &amp;lt;%= f.submit %&amp;gt;
    &amp;lt;% end %&amp;gt;
  &lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Lấy giá trị
  Có 2 trường hợp:
    - Nếu user_category có key_name không phải &quot;other content&quot; thì sẽ lấy giá trị &quot;content&quot; từ bảng &quot;category&quot;
    - Nếu users_category có key_name là &quot;other_content&quot; sẽ tiến hành lấy &quot;other_content&quot; từ trong bảng users_category
&lt;/section&gt;

&lt;section style=&quot;text-align: left;&quot;&gt;
  &lt;h3&gt; Lấy giá trị &lt;/h3&gt;
  &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
  # users_category.rb
  def category_name
    key_name == OTHER_CONTENT ? other_content : content
  end
  &lt;/code&gt;&lt;/pre&gt;

  &lt;pre style=&quot;width: 100%;&quot;&gt;&lt;code data-trim=&quot;&quot; data-noescape=&quot;&quot;&gt;
  # user.rb
  def show
    @user = User.find params[:id]
    @categories = @user.users_categories.map{|c| c.category_name}.join(&quot; ,&quot;)
  end
  &lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Trường hợp edit

  - Đối với trường hợp edit, khi chúng ta chạy đoạn:

  ```
is_selected = users_categories.map{|c| c.category_key_name}.include?(category_option.category_key_name)
  ```

  thì sẽ phải thực hiện truy vấn thông qua database để lấy lại association. Khi đó khi chúng ta cập nhật thay đổi giá trị cho ô select, ô đó sẽ luôn là giá trị cũ
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ![Select multi categories db](/assets/images/1.png)

&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ![Select multi categories db](/assets/images/2.png)

&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ![Select multi categories db](/assets/images/3.png)

&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Edit | Ý tưởng

  - Khi submit params lên chúng ta sẽ lọc được những params có category đã được chọn
  - Lọc và trả lại những id đó

  ```
  @selected_ids =
    users_categories_attributes.values.map {|c| c[:category_id] if c[:_destroy] == &quot;0&quot;}.compact
  ```

  - Kết quả: Mảng các categories đã selected. Ví dụ: [&quot;1&quot;, &quot;2&quot;]

&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Edit | Ý tưởng

  - Edit một chút trong view:

  ```
    selected_ids = @selected_ids ||
    users_categories.map{|c| c.category_id.to_s}
  ```

  ```
  is_selected = selected_ids.include?(category_option.category_id.to_s)
  ```

  - Kết quả: Mảng các categories đã selected. Ví dụ: [&quot;1&quot;, &quot;2&quot;]
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### Lưu ý

  - Khi cập nhật dữ liệu cần phải permit id của nested params để tránh tình trạng tạo thêm bản ghi mới giống bản ghi cũ.

  - Trong file edit.html.slim thêm hidden_field cho id của users_category.

  ```
  &amp;lt;%= ff.hidden_field :id, value: users_categories.select{|c| c.key_name == category.key_name}.first&amp;amp;.id %&amp;gt;
  ```
  Về bản chất neseted_attributes đã hỗ trợ tự điền id vào form nested nhưng trong trường hợp này giá trị của nested form được build ra không phải là giá trị trong quan hệ mà là giá trị của object `@category_options` chúng ta truyền vào nên cần phải lọc ra như trên.
  - Vị trí của categories(Đối với ;): Tìm hiểu kĩ design để khi import master
&lt;/section&gt;

&lt;section data-markdown=&quot;&quot; style=&quot;text-align: left;&quot;&gt;

  ### End.

  #### Cảm ơn mọi người đã lắng nghe!

&lt;/section&gt;
</description>
        <pubDate>Sat, 14 Dec 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/2019/12/14/select-multy-categories/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/12/14/select-multy-categories/</guid>
        
        
      </item>
    
      <item>
        <title>SQL WHERE vs HAVING</title>
        <description>&lt;pre&gt;&lt;code&gt;Where : Là câu lệnh điều kiện trả kết quả đối chiếu với từng dòng .
Having : Là câu lệnh điều kiện trả kết quả đối chiếu cho nhóm (Sum,AVG,COUNT,…)

Vì vậy mà sau GROUP BY thì sẽ chỉ dùng được Having .
còn Where thì KHÔNG dùng được sau GROUP BY.

(HAVING có thể thay thế vị trí dùng cho WHERE. nhưng . ngược lại WHERE thì KHÔNG thể thay thế vị trí cho HAVING )

&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 29 Nov 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/tech/2019/11/29/where-vs-having/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/2019/11/29/where-vs-having/</guid>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Restful webservice</title>
        <description>&lt;p&gt;&lt;em&gt;Rest là gì ?&lt;/em&gt;
Vậy REST là gì?&lt;/p&gt;

&lt;p&gt;REST là viết tắt của Representational State Transfer&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;là một kiểu kiến trúc lập trình, nó định nghĩa các quy tắc để thiết kết các web service chú trọng vào tài nguyên hệ thống.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Trong kiến trúc REST mọi thứ đều được coi là tài nguyên, chúng có thể là: tệp văn bản, ảnh, trang html, video, hoặc dữ liệu động… REST server cung cấp quyền truy cập vào các tài nguyên, REST client truy cập và thay đổi các tài nguyên đó. Ở đây các tài nguyên được định danh dựa vào URI, REST sử dụng một vài đại diện để biểu diễn các tài nguyên như văn bản, JSON, XML.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Để tạo một tài nguyên trên server ta dùng phương thức POST.&lt;/li&gt;
  &lt;li&gt;Để lấy(đọc) tài nguyên trên server ta dùng phương thức GET.&lt;/li&gt;
  &lt;li&gt;Để update tài nguyên trên server ta dùng phương thức PUT.&lt;/li&gt;
  &lt;li&gt;Để xóa tài nguyển trên server ta dùng phương thức DELETE.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;PUT VS PATH&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PUT (UPDATE): Cập nhật thông tin cho Resource.&lt;/li&gt;
  &lt;li&gt;PATCH (UPDATE): Cập nhật một thành phần, thuộc tính của Resource.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 29 Nov 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/tech/2019/11/29/resful-web-service/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/2019/11/29/resful-web-service/</guid>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>form_with — Building HTML forms in Rails 5.1</title>
        <description>&lt;p&gt;https://medium.com/@tinchorb/form-with-building-html-forms-in-rails-5-1-f30bd60ef52d&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Nov 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/tech/2019/11/29/form_with-vs-form_tag/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/2019/11/29/form_with-vs-form_tag/</guid>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Multi dynamic nested attributes trong rails</title>
        <description>&lt;p&gt;Chào mọi người, không như những bài trước mình đi từ lí thuyết tới thực hành mà bài viết này mình sẽ đưa ra một bài toán cụ thể mà chúng ta thường gặp phải để giải quyết.&lt;/p&gt;

&lt;h4 id=&quot;bài-toán&quot;&gt;Bài toán:&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;Hệ thống của chúng ta muốn tạo bài test trong đó có thể tùy ý thay đổi số lượng câu hỏi, trong mỗi câu hỏi sẽ có thể tùy ý thay đổi số lượng câu trả lời tương ứng.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sau một hồi research và nghe ngóng anh em thì mình đã được đưa ra một giải pháp là sử dụng nested attributes + kết hợp sử dụng gem &lt;a href=&quot;https://github.com/nathanvda/cocoon&quot;&gt;Cocoon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Để giải quyết bài toán đề ra, chúng ta cần tìm hiểu một số vấn đề:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Nested attributes là gì ? Và cách sử dụng&lt;/li&gt;
  &lt;li&gt;Gem cocoon là gì và tại sao sử dụng&lt;/li&gt;
  &lt;li&gt;Áp dụng sử dụng cho bài toán multi nested attributes&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-nested-attributes-là-gì-&quot;&gt;1. Nested attributes là gì ?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html&quot;&gt;Nested attributes&lt;/a&gt; cho phép bạn lưu những thuộc tính của các bản ghi liên quan thông qua các bản ghi cha mẹ. Mặc định trong rails nested attributes được tắt và bạn có thể bật nó lên bằng lệnh &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; trong model.&lt;/p&gt;

&lt;h4 id=&quot;11-cách-khai-báo&quot;&gt;1.1 Cách khai báo&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Quan hệ one-to-one&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;accepts_nested_attributes_for :attribute_name&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ví dụ mỗi user có một avatar, trong model user ta khai báo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User &amp;lt; ActiveRecord::Base
  has_one :avatar
  accepts_nested_attributes_for :avatar
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Khi kích hoạt nested attributes trong liên kết one-to-one cho phép bạn tạo User và Avatar trong một lần:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;params = { user: { name: 'Jack', avatar_attributes: { icon: 'avatar_default' } } }
user = User.create(params[:user])
user.avatar.id # =&amp;gt; 2
user.avatar.icon # =&amp;gt; 'avatar_default'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Tương tự khi update&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;params = { user: { avatar_attributes: { id: '2', icon: 'sad' } } }
user.update params[:user]
user.avatar.icon # =&amp;gt; 'sad'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Quan hệ one-to-many&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;accepts_nested_attributes_for :attribute_names&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ví dụ ta có mỗi user có nhiều bài posts:&lt;/p&gt;

&lt;p&gt;Ta tiến hành khai báo trong model:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class User &amp;lt; ActiveRecord::Base
  has_many :posts
  accepts_nested_attributes_for :posts
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ví dụ params khi tạo user đồng thời tạo luôn bài posts:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;params = { user: {
  name: 'joe', posts_attributes: [
    { title: 'Kari, the awesome Ruby documentation browser!' },
    { title: 'The egalitarian assumption of the modern citizen' }
  ]
}}

user = User.create(params[:user])
user.posts.length # =&amp;gt; 2
user.posts.first.title # =&amp;gt; 'Kari, the awesome Ruby documentation browser!'
user.posts.second.title # =&amp;gt; 'The egalitarian assumption of the modern citizen'
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;12-instance-public-methods&quot;&gt;1.2 Instance Public methods&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;:allow_destroy&lt;/code&gt;
Với option này, các thành phần của params gửi lên gửi kèm giá trị với key &lt;code&gt;_destroy&lt;/code&gt; và value à &lt;code&gt;true&lt;/code&gt; sẽ bị xóa.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ví dụ:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;member.avatar_attributes = { id: '2', _destroy: '1' }
member.avatar.marked_for_destruction? # =&amp;gt; true
member.save
member.reload.avatar # =&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ở ví dụ trên, avatar với id = 2 đã được xóa thành công.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;:reject_if&lt;/code&gt;
Với option này. Rails cho phép bạn sử dụng &lt;code&gt;Proc&lt;/code&gt; hoặc &lt;code&gt;Symbol&lt;/code&gt; để trỏ đến một phương thức để kiểm tra xem giá trị của &lt;code&gt;attributes&lt;/code&gt; có thỏa mãn hay không.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ví dụ sử dụng proc:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Member &amp;lt; ActiveRecord::Base
  has_many :posts
  accepts_nested_attributes_for :posts, reject_if: proc { |attributes| attributes['title'].blank? }
end

params = { member: {
  name: 'joe', posts_attributes: [
    { title: 'Kari, the awesome Ruby documentation browser!' },
    { title: 'The egalitarian assumption of the modern citizen' },
    { title: '' } # bản ghi này sẽ k đc lưu do không thỏa mãn điều kiện được định nghĩa trên `:reject_if`
  ]
}}
member = Member.create(params[:member])
member.posts.length # =&amp;gt; 2
member.posts.first.title # =&amp;gt; 'Kari, the awesome Ruby documentation browser!'
member.posts.second.title # =&amp;gt; 'The egalitarian assumption of the modern citizen'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ví dụ sử dụng &lt;code&gt;Symbol&lt;/code&gt; để khai báo hàm cần thực thi của &lt;code&gt;:reject_if&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Member &amp;lt; ActiveRecord::Base
  has_many :posts
  accepts_nested_attributes_for :posts, reject_if: :new_record?
end

class Member &amp;lt; ActiveRecord::Base
  has_many :posts
  accepts_nested_attributes_for :posts, reject_if: :reject_posts

  def reject_posts(attributes)
    attributes['title'].blank?
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;:limit&lt;/code&gt;
Option này cho phép bạn chỉ định số lượng bản ghi liên quan tối đa có thể được xử lý.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ví dụ:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Member &amp;lt; ActiveRecord::Base
  has_many :posts
  accepts_nested_attributes_for :posts, limit: 4
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;:update_only&lt;/code&gt;
Đối với quan hệ &lt;code&gt;one-to-one&lt;/code&gt;, option này cho phép bạn chỉ định cách xử lý đối với trường hợp bản ghi liên kết đã tồn tại. Thông thường, một bàn ghi tồn tại có thể được cập nhật giá bằng cách cập nhật giá trị mới cho nó hoặc chính nó được thay thế bằng bản ghi mới với giá trị cần cập nhật.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Mặc định thì &lt;code&gt;update_only&lt;/code&gt; là &lt;code&gt;false&lt;/code&gt; và nested attributes được sử dụng để cập nhật vào bản ghi nếu bản ghi đó tồn tại &lt;code&gt;id&lt;/code&gt;. Nếu không thì một bản ghi mới sẽ được khởi tạo để thay thế bản ghi hiện có. Tuy nhiên, nếu &lt;code&gt;:update_only&lt;/code&gt; option là &lt;code&gt;true&lt;/code&gt;, nested attributess sẽ luôn được sử dụng để cập nhật các giá trị của bản ghi nếu thuộc tính &lt;code&gt;:id&lt;/code&gt; đó đang tồn tại.&lt;/p&gt;

&lt;p&gt;*tips: khi sử dụng &lt;code&gt;update_only: true&lt;/code&gt;, bạn có thể cập nhật giá trị cho bản ghi con mà không cần thiết phải truyền &lt;code&gt;id&lt;/code&gt; lên trong params.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Member &amp;lt; ActiveRecord::Base
  has_one :avatar
  accepts_nested_attributes_for :avatar, update_only: true
end

params = { member: { avatar_attributes: { icon: 'sad' } } }
member.update params[:member]
member.avatar.id # =&amp;gt; 2
member.avatar.icon # =&amp;gt; 'sad'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2gem-cocoon-là-gì-và-tại-sao-sử-dụng-&quot;&gt;2.Gem cocoon là gì và tại sao sử dụng ?&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cocoon makes it easier to handle nested forms.&lt;/p&gt;

  &lt;p&gt;Nested forms are forms that handle nested models and attributes in one form; e.g. a project with its tasks or an invoice with its line items.&lt;/p&gt;

  &lt;p&gt;Cocoon is form builder-agnostic, so it works with standard Rails, Formtastic, or SimpleForm. It is compatible with rails 3, 4 and 5.&lt;/p&gt;

  &lt;p&gt;This project is not related to Apache Cocoon.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hiểu đơn giản, Gem &lt;code&gt;cocoon&lt;/code&gt; cũng như các gem khác của rails đều sinh ra để đáp ứng một nhu cầu cụ thể để có thể tối ưu và sử dụng lại. Ở đây, gem cocoon giúp người dùng có thể dễ dàng tương tác với nested forrms(form lồng nhau) thay vì phải ngồi viết những thứ js dài dòng để build ra form với attributes tương ứng (lazy time)&lt;/p&gt;

&lt;h4 id=&quot;21-cài-đặt&quot;&gt;2.1 Cài đặt&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thêm &lt;code&gt;gem &quot;concoon&quot;&lt;/code&gt; vào &lt;code&gt;Gemfile&lt;/code&gt; và chạy &lt;code&gt;bundle install&lt;/code&gt; để update gem của bạn.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Đối với rails 5, thêm dòng dưới vào file &lt;code&gt;application.js&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;//= require cocoon&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;22-cocoon-helper-functions&quot;&gt;2.2 Cocoon helper functions&lt;/h4&gt;
&lt;p&gt;Cocoon định nghĩa 2 helper functions:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/nathanvda/cocoon#link_to_add_association&quot;&gt;link_to_add_association&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/nathanvda/cocoon#link_to_remove_association&quot;&gt;link_to_remove_association&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;221-link_to_add_association&quot;&gt;2.2.1 link_to_add_association&lt;/h5&gt;

&lt;p&gt;Hàm này thêm một liên kết vào phần hiển thị của bạn, khi click vào liên kết sẽ tự động sinh ra một partial form đã được chúng ta định nghĩa sẵn.&lt;/p&gt;

&lt;p&gt;Ví dụ:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;= form_for @project do |f|
  .field
    = f.label :name_badge:
  %h3 Tasks
  #tasks
    = f.fields_for :tasks do |task|
      = render 'task_fields', f: task
    .links
      = link_to_add_association 'add task', f, :tasks
  = f.submit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Chúng ta cần khai báo thêm partial form với tên: &lt;code&gt;_task_fields&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; .nested-fields
  .field
    = f.label :description
    %br
    = f.text_field :description
  .field
    = f.check_box :done
    = f.label :done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;= link_to_add_association 'add task', f, :tasks&lt;/code&gt; sẽ tạo ra 1 thẻ &lt;code&gt;a&lt;/code&gt;, khi ta click vào thẻ này, &lt;code&gt;cocoon&lt;/code&gt; sẽ tự động giúp chúng ta tạo ra một form &lt;code&gt;task_field&lt;/code&gt; mới với giá trị &lt;code&gt;id&lt;/code&gt; được build tự động, giúp chúng ta dễ dàng hơn trong việc sử dụng nested form.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.viblo.asia/bfe044cc-df93-488f-8690-a5349c26b382.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;link_to_add_association&lt;/code&gt; gồm 4 tham số:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;name: text sẽ hiển thị của link&lt;/li&gt;
  &lt;li&gt;f: form builder&lt;/li&gt;
  &lt;li&gt;association: tên của association (phải là số nhiều) - đối tượng mới cần được thêm vào.&lt;/li&gt;
  &lt;li&gt;html_options: là mở rộng của html-options (&lt;a href=&quot;https://api.rubyonrails.org/classes/ActionView/Helpers/UrlHelper.html#method-i-link_to&quot;&gt;link_to&lt;/a&gt;). Và thêm một số tùy chỉnh đặc biệt của &lt;code&gt;cocoon&lt;/code&gt;:
    &lt;ul&gt;
      &lt;li&gt;data-association-insertion-traversal : phuơng thức &lt;code&gt;jquery traversal&lt;/code&gt; cho phép lựa chọn vị trí của partial khi được render. Có 3 option: &lt;code&gt;closest&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;children&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;data-association-insertion-node : Có thể hiểu đây là node mà field sẽ được chèn vào sau sự kiện clcik vào &lt;code&gt;link_to_add_association&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;data-association-insertion-method : quy định cách chèn field. Các option tương tự như jquery như:  before, after, append, prepend, etc. Mặc định sẽ là &lt;code&gt;before&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;data-association-insertion-position : phương thức cũ quy định nơi chèn dữ liệu mới( Hàm này sẽ được xóa trong version mới nên có lẽ không nên dùng các bác ạ :)) )&lt;/li&gt;
      &lt;li&gt;partial: tên của partial sẽ được sử dụng.&lt;/li&gt;
      &lt;li&gt;render_options: các tùy chọn chuyển qua form-builder.&lt;/li&gt;
      &lt;li&gt;wrap_object: một Proc sẽ cho phép bọc đối tượng của bạn, đặc biệt hữu ích nếu bạn đang sử dụng decorator (gem draper)&lt;/li&gt;
      &lt;li&gt;form_name : tên của tham số form truyền vào nested partial. Mặc định là &lt;code&gt;f&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;count:  số lượng mặc định nested items được chèn vào mỗi lần. Mặc định là 1.&lt;/p&gt;

        &lt;p&gt;Ví dụ: Bạn muốn chèn field partial vào một &lt;code&gt;div#parent&lt;/code&gt; nhất định, các partial sẽ nối tiếp nhau, mỗi lần nhấn vào link sẽ tạo ra 3 partial mới. &lt;code&gt;link_to_add_association&lt;/code&gt; sẽ có dạng:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;  = link_to_add_association &quot;add node&quot;, f, :questions,
    data: {&quot;association-insertion-node&quot;: &quot;#parent_table&quot;,
    &quot;association-insertion-method&quot;: &quot;append&quot;}, count: 3
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;render_options:  Bên trong &lt;code&gt;html_options&lt;/code&gt; bạn có thể thêm tùy chọn &lt;code&gt;:render_option&lt;/code&gt;và hàm băm chứa sẽ được chuyển xuống trình tạo biểu mẫu cho biểu mẫu được chèn.&lt;/p&gt;

        &lt;p&gt;Ví dụ:
   Khi dùng &lt;code&gt;simple_fields_for&lt;/code&gt; cần option &lt;code&gt;wrapper: 'inline'&lt;/code&gt; ta sẽ làm tương tự:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;   = link_to_add_association 'add something', f, :something,
       render_options: { wrapper: 'inline' }
&lt;/code&gt;&lt;/pre&gt;

        &lt;p&gt;Hoặc muốn truyền biến xuống p&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;   = link_to_add_association 'add something', f, :something,
       render_options: {locals: { sherlock: 'Holmes' }}
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;partial: Để định nghĩa là partial mặc định.
        &lt;pre&gt;&lt;code&gt;    = link_to_add_association 'add something', f, :something,
    partial: 'shared/something_fields'
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;wrap_object: Nếu bạn sử dụng decorator, khởi tạo bình thường của đối tượng liên quan sẽ không đủ. Bạn thực sự muốn tạo ra các đối tượng đã được decorate.&lt;/p&gt;

        &lt;p&gt;Ví dụ:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;    = link_to_add_association('add something', @form_obj, :comments,
        wrap_object: Proc.new {|comment| CommentDecorator.new(comment) })
&lt;/code&gt;&lt;/pre&gt;

        &lt;p&gt;Hoặc có thể sử dụng &lt;code&gt;:wrap_object&lt;/code&gt; để truyền thêm biến đã được xử lý xuống partial:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt; = link_to_add_association('add something', @form_obj, :comments,
   wrap_object: Proc.new { |comment| comment.name = current_user.name; comment })
&lt;/code&gt;&lt;/pre&gt;
        &lt;h5 id=&quot;222-link_to_remove_association&quot;&gt;2.2.2 link_to_remove_association&lt;/h5&gt;
        &lt;p&gt;Hàm này sẽ thêm 1 link vào phần hiển thị của bạn, khi click sẽ loại bỏ partial đó.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thành phần chính:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;name: text hiển thị tên nút, sử dụng tương tự như &lt;code&gt;link_to&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;f: đối tượng form hiện tại&lt;/li&gt;
  &lt;li&gt;html_options: tương tự html_options của &lt;code&gt;link_to&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-áp-dụng-sử-dụng-cho-bài-toán-multi-nested-attributes&quot;&gt;3. Áp dụng sử dụng cho bài toán multi nested attributes&lt;/h3&gt;
&lt;p&gt;Với bài toán multi nested (nhiều form lồng), chúng ta cần nắm rõ để có thể sử dụng linh hoạt gem &lt;code&gt;cocoon&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Trong trường hợp này mình sẽ đưa ra một ví dụ cụ thể:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Khi tạo 1 bài kiểm tra(exam) chúng ta cần tạo luôn các câu hỏi(question) và câu trả lời (answer) cho bài kiểm tra này.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Khởi tạo các model:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exam.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# frozen_string_literal: true

class Exam &amp;lt; ApplicationRecord
  has_many :questions

  accepts_nested_attributes_for :questions, allow_destroy: true, reject_if: :all_blank
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;question.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# frozen_string_literal: true

class Question &amp;lt; ApplicationRecord
  belongs_to :exam

  has_many :answers

  accepts_nested_attributes_for :answers, allow_destroy: true, reject_if: :all_blank
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;answer.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# frozen_string_literal: true

class Answer &amp;lt; ApplicationRecord
  belongs_to :question
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;exams_controller.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def new
  @exam = Exam.new
  @exam.questions.build
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tiếp đó trong view:
&lt;code&gt;exams/new.html.slim&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;= form_for @exam, url: exams_url do |f|
 .form-group.row
      label.col-md-3.form-control-label.text-primary.font-weight-bold Exam description
      #parent_table.col-md-9
        = f.fields_for :questions do |question|
      .js-new-question.ml-5
        = link_to_add_association f, :questions do
          span.fa.fa-plus
          span.ml-2 Add question
    = f.submit t(&quot;.save&quot;),class: &quot;btn btn-primary my-2&quot;

javascript:
  $(document).ready(function() {
    $(&quot;.js-new-question a.add_fields&quot;).
      data(&quot;association-insertion-method&quot;, 'append').
      data(&quot;association-insertion-node&quot;, '#parent_table');
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tiếp theo trong &lt;code&gt;_question_fields.html.slim&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.container-fluid.nested-fields
  .line
  .form-group.row
    .col-11
      = f.text_area :content, class: &quot;form-control&quot;
    .col-1
      = link_to_remove_association f do
        span.fa.fa-minus-square title=&quot;Remove question&quot;
    .question.col-md-9
      = link_to_add_association f, :answers, class: &quot;btn btn-info btn-sm mt-2&quot; do # chúng ta sẽ tiến hành khai báo để  tạo partial `answer` bên trong mỗi question.
        span.fa.fa-plus-circle
        span.ml-2 Add answer
      = f.fields_for :answers do |answer|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cuối cùng là &lt;code&gt;answer_fields.html.slim&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.col-6
  .row.pt-2
    .col-10
      = f.text_field :content, class: &quot;form-control&quot;
    .col-1
      = link_to_remove_association f do
        span.fa.fa-minus-square title=&quot;Remove question&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*Ở trên mình dùng slim và một số class bootstrap 4 cho code của mình, chú ý: phần data đã được di chuyển ra bên ngoài form và để trong đoạn &lt;code&gt;javascript&lt;/code&gt; do khi chúng ta tạo ra nhiều form lồng, ta cần định nghĩa class cha của chúng (ở đây mình định nghĩa là &lt;code&gt;js-new-question&lt;/code&gt;) để khi oncick vào &lt;code&gt;link_to_remove_association&lt;/code&gt; *&lt;/p&gt;

&lt;p&gt;Demo:
&lt;img src=&quot;https://images.viblo.asia/792519e2-fe73-42c6-9124-b2c09b329ea8.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tham khảo:&lt;/p&gt;

&lt;p&gt;https://github.com/nathanvda/cocoon#link_to_remove_association
https://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Nov 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/tech/2019/11/12/multi-nested-fields-rails/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/2019/11/12/multi-nested-fields-rails/</guid>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Rails 6 - Active Storage changes</title>
        <description>&lt;p&gt;This article found in: https://blog.saeloun.com/2019/11/04/rails-6-active-storage-updates.html&lt;/p&gt;

&lt;p&gt;Active Storage was introduced in Rails 5.2. In rails 6, the are enhancements (nâng cao) done to Active Storage.&lt;/p&gt;

&lt;p&gt;Let’s explore them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mini_magick replaced by image_processing gem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In rails 5.2, Active Storage was using &lt;code&gt;mini_magick&lt;/code&gt; to handle (xử lý) image resizing(variants) (Kích thước)&lt;/p&gt;

&lt;p&gt;In rails 6, a new gem called &lt;code&gt;image_processing&lt;/code&gt; is used by default to handle image variants
(Trong rails 6, gem &lt;code&gt;image_processing&lt;/code&gt; được sử dụng làm mặc định để xử lý việc thay đổi kích thước ảnh)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;image_processing&lt;/code&gt; gem has below advantages(Lợi thế):&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;New methods #resize_to_fit, #resize_to_fill, etc also sharpens the thumbnail (làm sắc nét hình ảnh) after resizing.&lt;/li&gt;
  &lt;li&gt;It fixes the image orientation automatically (tự động sử đổi hướng hình ảnh).&lt;/li&gt;
  &lt;li&gt;It provides another backend libvips that has significantly better performance than (Hiệu suất tốt hơn đáng kể) ImageMagick. With ImageMagick, resizing and sharpening (thay đổi kích cỡ và làm nét) a 1600x900 image to 800x800 is 1.87x slower, and to 300x300 is 1.18x slower. On libvips it doesn’t go above 1.20x slower, on average (trung bình) it’s only about 1.10x slower.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;New image variants support&lt;/strong&gt; (Hỗ trợ biến thể hình ảnh mới)
With addition (việc thêm) of image_processing gem, support for new image variants BMP (PR), TIFF (PR) and progressive JPEG (PR) was introduced (đã được giới thiệu).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fix for &lt;code&gt;has_many_attached&lt;/code&gt; field in update query&lt;/strong&gt;
Let’s say we have a User class and it has field images. Users can upload multiple images to their profiles. So we add has_many_attached method to User class as shown below&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User &amp;lt; ApplicationRecord
  has_many_attached :images
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Before Rails 6:&lt;/em&gt;
We attach (đính kèm)) an image to the user as shown below and verify the count&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user = User.first
user.images.attach(filename: &quot;profile_pic.jpg&quot;)

user.images.count
=&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, when we update the image field, the new image was getting appended to the existing images collection.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blog = ActiveStorage::Blob.create_after_upload!(filename: &quot;updated_pic.jpg&quot;)
user.update(images: [blog])

user.images.count
=&amp;gt; 2
user.images.first.filename
=&amp;gt; &quot;profile_pic.jpg&quot;
user.images.last.filename
=&amp;gt; &quot;updated_pic.jpg&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is not consistent (Không thích hợp) with ActiveRecord update, where it replaces the existing value of a record.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In rails 6:&lt;/em&gt;
update query replaces the existing collection instead of appending to the collection.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user.images.attach(filename: &quot;profile_pic.jpg&quot;)

user.images.count
=&amp;gt; 1

blog = ActiveStorage::Blob.create_after_upload!(filename: &quot;updated_pic.jpg&quot;)
user.update(images: [blog])

user.images.count
=&amp;gt; 1
user.images.first.filename
=&amp;gt; &quot;updated_pic.jpg&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We can append files by using the attach function.&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Nov 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/tech/2019/11/12/rails-6-active-storage-changes/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/2019/11/12/rails-6-active-storage-changes/</guid>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Sử dụng scopes trong Ruby on Rails</title>
        <description>&lt;p&gt;This article found in: https://www.rubyguides.com/2019/10/scopes-in-ruby-on-rails/&lt;/p&gt;

&lt;p&gt;Let’s begin!&lt;/p&gt;

&lt;p&gt;What is scope in Rails &amp;amp; why is it useful (hữu ích) ?&lt;/p&gt;

&lt;p&gt;Well…&lt;/p&gt;

&lt;p&gt;Scopes are custom queries (Truy vấn tùy chỉnh) that you define inside (bên trong) your Rails models with the &lt;code&gt;scope&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Every scope takes two arguments:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;A name, which you use to call this scope in your code&lt;/li&gt;
  &lt;li&gt;A lambda, which implements the query&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It looks like this (trông như):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Fruit &amp;lt; ApplicationRecord
  scope :with_juice, -&amp;gt; { where(&quot;juice &amp;gt; 0&quot;) }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a result of calling a scope, you’ll get an &lt;code&gt;ActiveRecord::Relation&lt;/code&gt; object.
(Kết quả khi sử dụng &lt;code&gt;scope&lt;/code&gt;, bạn sẽ nhận được một &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Which means you can chain &amp;amp; combine scopes!
(Điều đó có nghĩa rằng bạn có thể kết hợp các scope lại với nhau)&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Fruit.with_juice.with_round_shape.first(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;p&gt;There’s more to learn about Rails scopes, so let’s keep exploring the topic.
(Phần mở rộng)&lt;/p&gt;

&lt;h3 id=&quot;when-to-use-scope--khi-nào-sử-dụng-scope-&quot;&gt;When to use scope ? (Khi nào sử dụng scope ?)&lt;/h3&gt;
&lt;p&gt;Ok, scopes are cool, but when should you use them?&lt;/p&gt;

&lt;p&gt;Let’s see an example.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def index
  @books = Book.where(&quot;LENGTH(title) &amp;gt; 20&quot;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an index controller action that wants to display books with titles longer than 20 characters.
(Trong action index trên muốn hiển thị những đối tượng books mà title có độ dài &amp;gt; 20 kí tự)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It’s fine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;But if you want to use this query in other places, you’re going to have duplicated code.
(Nhưng nếu bạn muốn sử dụng lại câu truy vấn trên ở nơi khác, bajnn sẽ lặp lại code)&lt;/p&gt;

&lt;p&gt;Duplicated code makes your project harder to maintain.
(Lặp lại code khiến dự án của bạn khó khăn cho maintain)&lt;/p&gt;

&lt;p&gt;Let’s move this query into a scope.
(Hãy di chuyển những câu truy vấn đó vào scope)&lt;/p&gt;

&lt;p&gt;Like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Book
  scope :with_long_title, -&amp;gt; { where(&quot;LENGTH(title) &amp;gt; 20&quot;) }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now our controller action looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def index
  @books = Book.with_long_title
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;how-to-use-rails-scopes-with-arguments-sử-dụng-scope-với-đối-số&quot;&gt;How to Use Rails Scopes With Arguments (Sử dụng scope với đối số)&lt;/h3&gt;
&lt;p&gt;You may want to introduce a variable into a scope so you can make it more flexible.
(Bạn có thể muốn khai báo &lt;code&gt;biến&lt;/code&gt; trong scope để có thể khiến scope trở nên linh hoạt hơn)&lt;/p&gt;

&lt;p&gt;Here’s how:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Book
  scope :with_long_title, -&amp;gt;(length) { where(&quot;LENGTH(title) &amp;gt; ?&quot;, length) }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The question mark (?) is a placeholder, it’ll be replaced by the value of length. This makes your code safer.
(Dấu &lt;code&gt;?&lt;/code&gt; là một phần trống, nó sẽ được thay bằng giá trị của chiều dài tức biến truyền vào. Nó làm cho code trở nên an toàn hơn))&lt;/p&gt;

&lt;p&gt;If you want a default value:
(Khi cần khai báo giá trị mặc định của biến truyền vào:)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Book
  scope :with_long_title, -&amp;gt;(length = 20) { where(&quot;LENGTH(title) &amp;gt; ?&quot;, length) }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Give it a try!
(Hãy thử dùng nó)&lt;/p&gt;

&lt;h3 id=&quot;scope-vs-instance-method-so-sánh-scope-và-hàm-instance&quot;&gt;Scope vs Instance Method (So sánh scope và hàm instance)&lt;/h3&gt;
&lt;p&gt;Scopes aren’t doing anything magical or super special.
(Scope không làm bất cứ điều gì kỳ diệu hoặc siêu đặc biệt)&lt;/p&gt;

&lt;p&gt;They are just methods.
(Chúng chỉ là methods)&lt;/p&gt;

&lt;p&gt;In fact… You could do the same thing using class methods!
(Bạn có thể làm tương tự bằng các sử dụng &lt;code&gt;class methods&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Fruit
  def self.with_juice
    where(&quot;juice &amp;gt; 0&quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there are design advantages to using scopes over class methods.
(Nhưng có những lợi ích về mặt design để dử dụng scopes hơn là sử dụng &lt;code&gt;class method&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Here’s why:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Scopes result in cleaner code because of their syntax
(Scopes trông sạch sẽ hơn vì cú pháp đơn giản của nó)&lt;/li&gt;
  &lt;li&gt;Scopes are used for exactly one thing, so you know what you get the moment you see one
(Scope được sử dụng chính xác cho một mục đích, vì vậy bạn có thể biết ngay mục đích của scope đó ngay khi bạn đọc)&lt;/li&gt;
  &lt;li&gt;Scopes aren’t mixed with other methods, so they’re easier to spot
(Scope không trộn lẫn với các &lt;code&gt;methods&lt;/code&gt; khác, vì thế nó dễ dàng có thể được phát hiện ra trong code)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In terms of functionality, the only difference is that scopes guarantee an ActiveRecord::Relation, and class methods don’t.
(Về mặt chức năng, điều khác biệt duy nhất mà scope bảo đảm đó chính là trả về một &lt;code&gt;ActiveRecord::Relation&lt;/code&gt; mà &lt;code&gt;class methods&lt;/code&gt; thì không.)&lt;/p&gt;

&lt;p&gt;This helps you avoid errors when your scope returns nothing.
(Điều đó giuos tránh được lỗi khi &lt;code&gt;scope&lt;/code&gt; không trả về  kết quả)&lt;/p&gt;

&lt;h3 id=&quot;dont-use-default-scopes-không-sử-dụng-default-scope&quot;&gt;Don’t Use Default Scopes (Không sử dụng default scope)&lt;/h3&gt;
&lt;p&gt;A default scope is one which is automatically applied to your model.
(Default scope là scope luôn được áp dụng cho model khi khởi tạo)&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Post
  default_scope { where(published: true) }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Default scopes are so attractive(hấp dẫn).
But they’re often the wrong choice (Lựa chọn sai) because you’ll probably forget (có thể quên) you have them defined, run into strange errors (chạy vào những lỗi lạ), and waste precious time (lãng phí thời gian quý báu) debugging.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;With that said…&lt;/strong&gt; (Khắc phục khi sử dụng default scope)
If you have to work with default scopes, you may need to use the unscoped method to disable all currently applied scopes.&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Nov 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/tech/2019/11/12/how-to-use-scopes-in-ruby-on-rails/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/2019/11/12/how-to-use-scopes-in-ruby-on-rails/</guid>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Ruby inject vs each_with_object</title>
        <description>&lt;p&gt;Có thể bạn đã nghe qua hoặc đã dùng thử với &lt;code&gt;inject&lt;/code&gt; và &lt;code&gt;each_with_object&lt;/code&gt; nhưng chưa thực sự hiểu sâu về chúng mà chỉ đọc qua guide về cách sử dụng căn bản. Hôm nay chúng ta sẽ đi sâu tìm hiểu để có một cái nhìn sâu hơn về &lt;code&gt;inject&lt;/code&gt; và &lt;code&gt;each_with_object&lt;/code&gt; thông qua các ví dụ trực quan.&lt;/p&gt;

&lt;h3 id=&quot;inject&quot;&gt;inject&lt;/h3&gt;
&lt;p&gt;Định nghĩa trên trang  &lt;a href=&quot;https://apidock.com/rails/Enumerable/inject&quot;&gt;apidock&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;inject(p1 = v1, p2 = v2)&lt;/p&gt;

  &lt;p&gt;Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Tốt hơn cho các hoạt động trên các đối tượng/collections có thể thay đổi giá trị và trả về một giá trị mới&lt;/li&gt;
  &lt;li&gt;Tốt cho các đối tượng nguyên thủy và các đối tượng mà trả về giá trị mới khi thay đổi.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;each_with_object&quot;&gt;each_with_object&lt;/h3&gt;
&lt;p&gt;Định nghĩa trên trang  &lt;a href=&quot;https://apidock.com/rails/Enumerable/each_with_object&quot;&gt;apidock&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;each_with_object(memo) public&lt;/p&gt;

  &lt;p&gt;Iterates over a collection, passing the current element and the memo to the block. Handy for building up hashes or reducing collections down to one object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Tốt hơn cho các hoạt động có thể thay đổi trên các đối tượng như là Hash hoặc Array&lt;/li&gt;
  &lt;li&gt;Khi sử dụng chúng ta cần cung cấp một đối tượng mới để bắt đầu và sử dụng đối tượng nó. Và dĩ nhiên sẽ không hữu dụng nếu bạn muốn sửa đổi trên 1 đối tượng hiện tại.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Bây giờ chúng ta sẽ cùng nhau đi vào ví dụ để làm rõ những luận điểm trên!&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;vd1&quot;&gt;VD1:&lt;/h3&gt;
&lt;p&gt;Hãy chú ý tới các ví dụ khác nhau. Tưởng tượng bạn có một tập hợp các đối tượng và bạn muốn tạo ra một &lt;code&gt;hash&lt;/code&gt; sử dụng chúng và thực hiện một số loại ánh xạ khác nhau.&lt;/p&gt;

&lt;p&gt;Cùng tìm hiểu vấn đề:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bạn muốn xây dựng một đối tượng mới (Hash `lower_to_upper)&lt;/li&gt;
  &lt;li&gt;Bắt đầu với hash trống &lt;code&gt;{}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trong trường hợp này, &lt;code&gt;each_with_object&lt;/code&gt; rất tiện lợi:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lower = 'a'..'z'
lower_to_upper = lower.each_with_object({}) do |char, hash|
  hash[char] = char.upcase
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cùng xem sử dụng &lt;code&gt;inject&lt;/code&gt; nhưng có vẻ không tiện lợi bằng việc sử dụng &lt;code&gt;each_with_object&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lower = 'a'..'z'
lower_to_upper = lower.inject({}) do |hash, char|
  hash[char] = char.upcase
  hash
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nguyên nhân vì &lt;code&gt;inject&lt;/code&gt; yêu cầu giá trị để ghi nhớ cho block trong các lần sử dungj tiếp theo (&lt;code&gt;hash&lt;/code&gt; được khởi tạo với &lt;code&gt;{}&lt;/code&gt;) được trả về sau mỗi lần lặp qua &lt;code&gt;block&lt;/code&gt;. Vì vậy mặc dù bạn liên tục hoạt động trên cùng một đối tượng, bạn luôn cần nó được trả về ở cuối của khối.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;each_with_object&lt;/code&gt; mặt khác luôn gọi khối có cùng một đối tượng ban đầu được truyền làm đối số đầu tiên cho method.&lt;/p&gt;

&lt;h3 id=&quot;vd2&quot;&gt;VD2&lt;/h3&gt;
&lt;p&gt;Nhưng với trường hợp bạn đã có một đối tượng hiện để thay đổi. Trong trường hợp như vậy, thông thường bạn nên sử dụng &lt;code&gt;each&lt;/code&gt; thay vì &lt;code&gt;each_with_object&lt;/code&gt; nhưng &lt;code&gt;each_with_object&lt;/code&gt; có thể ngắn hơn một chút nếu bạn vẫn cần trả về đối tượng đã thay đổi.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Sử dụng each:&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mapping = {'ż' =&amp;gt; 'Ż', 'ó' =&amp;gt; 'Ó'}
lower = 'a'..'z'
lower.each do |char|
  mapping[char] = char.upcase
end
return mapping # optionally
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Sử dụng &lt;code&gt;each_with_object&lt;/code&gt;:&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mapping = {'ż' =&amp;gt; 'Ż', 'ó' =&amp;gt; 'Ó'}
lower = 'a'..'z'
lower.each_with_object(mapping) do |char, hash|
  hash[char] = char.upcase
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mapping = {'ż' =&amp;gt; 'Ż', 'ó' =&amp;gt; 'Ó'}
lower = 'a'..'z'
lower.each_with_object(mapping) do |char|
  mapping[char] = char.upcase
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nhấn mạnh ở đây &lt;code&gt;each&lt;/code&gt; sẽ tốt hơn nếu bạn muốn thay đổi một tập hợp hiện có, bởi vì thông thường bạn không cần phải &lt;code&gt;return&lt;/code&gt;. Sau cùng, bất cứ khi nào đối tượng làm đối số, cho dù xuất phát từ đâu, có thể vẫn đang có đối tượng tham chiếu đến đối tượng này.&lt;/p&gt;

&lt;h3 id=&quot;vd3&quot;&gt;VD3&lt;/h3&gt;
&lt;p&gt;Trong ví dụ tiếp theo sẽ không thay đổi trạng thái bên trong của đối tượng mà luôn tạo ra một đối tượng mới. Pháp tóan sử dụng sẽ luôn trả về một đối tượng mới.&lt;/p&gt;

&lt;p&gt;Ví dụ đơn giản nhất là toán tử &lt;code&gt;+&lt;/code&gt; số.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = 1
b = 2

a.frozen?
# =&amp;gt; true
b.frozen?
# =&amp;gt; true

c = a + b
# =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Không có cách nào để thay đổi đối tượng &lt;code&gt;integer&lt;/code&gt; được tham chiếu bởi biến a thành 3. ĐIều duy nhất có thể làm là gán một đối tượng khác cho biến a hoặc bằn b hoặc c.&lt;/p&gt;

&lt;p&gt;Tiếp theo là một ví dụ rõ ràng hơn:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require 'date'
d = Date.new(2017, 10, 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nếu bạn muốn một ngày khác, bạn không thể thay đổi instance &lt;code&gt;Date&lt;/code&gt; hiện tại. Bạn cần tạo một instance mới.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d.day=12
# =&amp;gt; NoMethodError: undefined method `day=' for #&amp;lt;Date:

e = Date.new(2017, 10, 12)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hey, sau một vài ví dụ đơn giản chúng ta đã phần nào hiểu được chúng ta có gì khi làm chủ được &lt;code&gt;inject&lt;/code&gt; nếu bạn có một đối tượng bất biến, &lt;code&gt;inject&lt;/code&gt; là sự lựa chọn hoàn hảo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(5..10).inject(:+)
(5..10).inject(0, :+)
(5..10).inject{|sum, n| sum + n }

(5..10).inject(1, :*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hoặc:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;starting_date = Date.new(2019,10,20)
result = [1, 10].inject(starting_date) do |date, delay|
  date + delay
end
# =&amp;gt; Date.new(2017,10,31)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vd4&quot;&gt;VD4&lt;/h3&gt;
&lt;p&gt;Làn này chúng ta sẽ tạo một đối tượng mới môi lần nhưng không phải vì có thể thay đổi trạng thái bên trong mà bởi vì phương thức đó nhất định sẽ trả về một đối tượng mới.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;result = [
 {1 =&amp;gt; 2},
 {2 =&amp;gt; 3},
 {3 =&amp;gt; 4},
 {1 =&amp;gt; 5},
].inject(:merge)
# =&amp;gt; {1=&amp;gt;5, 2=&amp;gt;3, 3=&amp;gt;4}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Hash#merge&lt;/code&gt; gộp hai hashes và trả về hash mới. Điều đó giải thích vì sao chúng ta có thể dễ dàng sử dụng với &lt;code&gt;inject&lt;/code&gt;
Sẽ ngắn gọn hơn so với:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
 {1 =&amp;gt; 2},
 {2 =&amp;gt; 3},
 {3 =&amp;gt; 4},
 {1 =&amp;gt; 5},
].each_with_object({}) {|element, hash| hash.merge!(element) }
# =&amp;gt; {1=&amp;gt;5, 2=&amp;gt;3, 3=&amp;gt;4}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Funny&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Có một điều lạ là các phần tử truyền vào block của &lt;code&gt;inject&lt;/code&gt; và &lt;code&gt;each_with_object&lt;/code&gt; đảo ngược nhau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lower_to_upper = lower.each_with_object({}) do |char, `hash`|
  hash[char] = char.upcase
end

lower_to_upper = lower.inject({}) do |`hash`, char|
  hash[char] = char.upcase
  hash
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hi vọng sau bài này các bạn có thể hiểu thêm về &lt;code&gt;inject&lt;/code&gt; và &lt;code&gt;each_with_object&lt;/code&gt;. Chúc các bạn một ngày vui vẻ :D&lt;/p&gt;

&lt;p&gt;Nguồn: https://blog.arkency.com/inject-vs-each-with-object/&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Sep 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/tech/2019/09/09/ruby-inject-vs-each_with_object/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/2019/09/09/ruby-inject-vs-each_with_object/</guid>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Learn SQL advanced</title>
        <description>&lt;p&gt;The first thing i want tell about the first link i found from google. It make by qoura. Fine, i like it: https://www.quora.com/How-do-I-learn-more-advanced-SQL&lt;/p&gt;

&lt;p&gt;Firstly i want learn SQL from basic, because maybe i’m a beginer in every thing. Of course, i dont like this. But some day, when i joined my project, i know i am a chicken. So, if i’m not a bigger, i will be a person.&lt;/p&gt;

&lt;p&gt;First ez query:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM Customers;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This query will select all record with all attributes of Customers.&lt;/p&gt;

&lt;h3 id=&quot;select-distinct&quot;&gt;SELECT DISTINCT&lt;/h3&gt;
&lt;p&gt;The SQL select distinct statement is used to return only distinct(diffirent) values.
Inside a table, a column often contains many duplicate values, and sometimes you only want to list the different (distinct) value.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Syntax:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT DISTINCT column1, column2,..
FROM table_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT DISTINCT Country FROM Customers;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This query will have result all different Country of customer.&lt;/p&gt;

&lt;h3 id=&quot;where-clause&quot;&gt;WHERE Clause&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;where&lt;/code&gt; clause is used to filter records.
The &lt;code&gt;where&lt;/code&gt; clause is used to extract only those records that fulfill a specified condition (Đáp ứng một điều kiện cụ thể).
&lt;code&gt;Syntax:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column1, column2
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This query will return the records of column1 and column2 with condition is &lt;code&gt;condition&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;###&lt;/p&gt;

&lt;h3 id=&quot;sql-order-by&quot;&gt;SQL ORDER BY&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;order by&lt;/code&gt; key word is used to sort the result-set in ascending or desending order.
In the default, the &lt;code&gt;order by&lt;/code&gt; will sort the records in ascending order by default. To sort records &lt;code&gt;desending&lt;/code&gt;, use &lt;code&gt;DESC&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ... ASC|DESC;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;insert-into&quot;&gt;INSERT INTO&lt;/h3&gt;
&lt;p&gt;Used to insert new records in table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ex:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)
VALUES ('Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway');
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sql-null-value&quot;&gt;SQL NULL VALUE&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;What is null value?&lt;/em&gt;
A field wit null value is field with no vale.&lt;/p&gt;

&lt;p&gt;IS NULL syntax&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT column_names
FROM table_name
WHERE column_name IS NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;IS NOT NULL syntax&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column_names
FROM table_name
WHERE column_name IS NOT NULL;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 09 Sep 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/tech/2019/09/09/sql-advanced/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/2019/09/09/sql-advanced/</guid>
        
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Những tricks khi học JSX</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Nội dung bài viết xoay quanh khóa học trên &lt;a href=&quot;https://www.codecademy.com/courses/react-101/lessons/react-jsx-advanced/exercises/self-closing-tags?action=resume_content_item&quot;&gt;Codecademy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;class-vs-classname&quot;&gt;class vs className&lt;/h3&gt;
&lt;p&gt;Trong HTML, &lt;code&gt;class&lt;/code&gt; thường được sử dụng để đặt tên cho thuộc tính của đối tượng&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1 class=&quot;big&quot;&amp;gt;Hey&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong JSX, chúng ta không thể sử dụng &lt;code&gt;class&lt;/code&gt; mà phải sử dụng &lt;code&gt;className&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1 className=&quot;big&quot;&amp;gt;Hey&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is because JSX gets translated into (được định dạng sang) JavaScript, and class is a reserved word (danh từ riêng) in JavaScript. Khi JSX rendered (được biểu diễn) JSX &lt;code&gt;className&lt;/code&gt; attributes (thuộc tính) are automatically rendered as &lt;code&gt;class&lt;/code&gt; attributes.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import React from 'react';
import ReactDOM from 'react-dom';

// Write code here:
const myDiv = (
	&amp;lt;div className=&quot;big&quot;&amp;gt;
    I AM A BIG DIV
  &amp;lt;/div&amp;gt;
)

ReactDOM.render(myDiv, document.getElementById('app'))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;self-closing-tags&quot;&gt;Self-Closing Tags&lt;/h3&gt;
&lt;p&gt;Another JSX ‘gotcha’ (Một bất ngờ của JSX) involves (liên quan) self-closing tags (các thẻ tự động đóng).&lt;/p&gt;

&lt;p&gt;What’s a self-closing tag?&lt;/p&gt;

&lt;p&gt;Most (phần lớn) HTML elements(thành phần) use two tags: an opening tag (&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;), and a closing tag (&lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt;). However, some HTML elements such as (như là) &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; use only one tag. The tag that belongs to(thuộc về) a single-tag element isn’t an opening tag nor a closing tag; it’s a self-closing tag.&lt;/p&gt;

&lt;p&gt;When you write a self-closing tag in HTML, it is optional to include a forward-slash (dấu gạch chéo) immediately before (ngay trước) the final angle-bracket (dấu ngoặc nhọn cuối cùng):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fine in HTML with a slash:

  &amp;lt;br /&amp;gt;

Also fine, without the slash:

  &amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But!&lt;/p&gt;

&lt;p&gt;In JSX, you have to include (phải bao gồm) the slash (dấu gạch chéo). If you write a self-closing tag in JSX and forget the slash (quên dấu gạch chéo), you will raise (nhận) an error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fine in JSX:

  &amp;lt;br /&amp;gt;

NOT FINE AT ALL in JSX:

  &amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;curly-braces-dấu-ngoặc-nhọn-in-jsx&quot;&gt;Curly Braces (Dấu ngoặc nhọn) in JSX&lt;/h3&gt;

&lt;p&gt;Any code in between (nằm giữa) the tags of a JSX element will be read as JSX (đọc dưới dạng JSX), not as regular (cú pháp) JavaScript! JSX doesn’t add numbers - it reads them as text, just like HTML.&lt;/p&gt;

&lt;p&gt;You need a way to write code that says, “Even though I am located in between JSX tags, treat me like ordinary JavaScript and not like JSX.”&lt;/p&gt;

&lt;p&gt;You can do this by wrapping (đóng gói) your code in curly braces (dấu ngoặc nhọn).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 5
&amp;lt;h1&amp;gt;{2 + 3}&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;variables-biến-in-jsx&quot;&gt;Variables (biến) in JSX&lt;/h3&gt;

&lt;p&gt;When you inject (đưa) JavaScript into JSX, that JavaScript is part of the same environment (một phần của môi trường tương ứng) as the rest (phần còn lại) of the JavaScript in your file.&lt;/p&gt;

&lt;p&gt;That means that you can access (truy cập) variables while inside (trong khi bên trong) of a JSX expression, even if those (ngay cả khi) variables were declared (được khai báo) on the outside.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Declare a variable:
const name = 'Gerdo';

// Access your variable
// from inside of a JSX expression:
const greeting = &amp;lt;p&amp;gt;Hello, {name}!&amp;lt;/p&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;variable-attributes-các-thuộc-tính-biến-in-jsx&quot;&gt;Variable Attributes (các thuộc tính biến) in JSX&lt;/h3&gt;

&lt;p&gt;When writing JSX, it’s common to use variables (các biến) to set attributes (các thuộc tính).&lt;/p&gt;

&lt;p&gt;Here’s an example of how that might work (cách nó hoạt động):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Use a variable to set the `height` and `width` attributes:

const sideLength = &quot;200px&quot;;

const panda = (
  &amp;lt;img
    src=&quot;images/panda.jpg&quot;
    alt=&quot;panda&quot;
    height={sideLength}
    width={sideLength} /&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how in this example, the &lt;code&gt;&amp;lt;img /&amp;gt;&lt;/code&gt;‘s attributes each get their own line. This can make your code more readable (dễ đọc) if you have a lot of attributes (có nhiều thuộc tính) on one element (thành phần).&lt;/p&gt;

&lt;p&gt;Object properties (thuộc tính đối tượng) are also often used to set attributes (đặt thuộc tính):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const pics = {
  panda: &quot;http://bit.ly/1Tqltv5&quot;,
  owl: &quot;http://bit.ly/1XGtkM3&quot;,
  owlCat: &quot;http://bit.ly/1Upbczi&quot;
};

const panda = (
  &amp;lt;img
    src={pics.panda}
    alt=&quot;Lazy Panda&quot; /&amp;gt;
);

const owl = (
  &amp;lt;img
    src={pics.owl}
    alt=&quot;Unimpressed Owl&quot; /&amp;gt;
);

const owlCat = (
  &amp;lt;img
    src={pics.owlCat}
    alt=&quot;Ghastly Abomination&quot; /&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;event-sự-kiện-listeners--lắng-nghe-in-jsx&quot;&gt;Event (sự kiện) Listeners  (lắng nghe) in JSX&lt;/h3&gt;
&lt;p&gt;https://www.codecademy.com/courses/react-101/lessons/react-jsx-advanced/exercises/jsx-event-listeners?action=resume_content_item&lt;/p&gt;

&lt;p&gt;JSX elements (các phần tử ) can have event listeners (sự kiện lắng nghe), just like HTML elements can. Programming (lập trình) in React means constantly working (liên tục làm việc) with event listeners.&lt;/p&gt;

&lt;p&gt;You create an event listener by giving a (cung cấp) JSX element a special attribute (thuộc tính đặc biệt). Here’s an example:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;img onClick={myFunc} /&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An event listener attribute’s name should be something like onClick or onMouseOver: the word on, plus the type of event that you’re listening for. You can see a list of valid event names here.&lt;/p&gt;

&lt;p&gt;An event listener attribute’s value should be a function. The above example would only work if myFunc were a valid function that had been defined elsewhere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function myFunc() {
  alert('Make myFunc the pFunc... omg that was horrible i am so sorry');
}

&amp;lt;img onClick={myFunc} /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in HTML, event listener names are written in all lowercase, such as onclick or onmouseover. In JSX, event listener names are written in camelCase, such as onClick or onMouseOver.&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Aug 2019 00:00:00 +0700</pubDate>
        <link>http://localhost:4000/tech/2019/08/27/reactjs-jsx/</link>
        <guid isPermaLink="true">http://localhost:4000/tech/2019/08/27/reactjs-jsx/</guid>
        
        
        <category>tech</category>
        
      </item>
    
  </channel>
</rss>
